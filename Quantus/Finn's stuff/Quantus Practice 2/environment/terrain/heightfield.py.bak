from pandac.PandaModules import GeoMipTerrain, Texture, Filename, TextureStage, TexGenAttrib,VBase4D
from direct.showbase.DirectObject import *
from direct.task.Task import Task
from direct.gui.OnscreenImage import OnscreenImage
from quantusUtils.Perlin import Perlin
from pandac.PandaModules import PNMImage,PNMPainter,PNMBrush
from direct.task import Task
import random
#Modified heightfield by Finn, using the more efficient "GeoMipTerrain"
#Not yet working properly, using bruteforce mode


MAPSIZE = 10000.0
TEXSIZE = 512.0

class Heightfield( DirectObject ):
	def __init__( self ):
		try:
			import psyco
			psyco.full()
		except ImportError:
			pass
		self.setupHeightfield()
	
	def setupHeightfield( self ):
		self.terrain = GeoMipTerrain("mySimpleTerrain")
		
		size = int(TEXSIZE) + 1
		randSeed = random.random()
		p1 = Perlin.Perlin( persistance = 0.500, smooth = False, seed = randSeed )
		self.myImage = p1.imgNoise2D(size,True)
		
		self.terrain.setHeightfield(self.myImage)
		self.terrain.setBruteforce(True)
		
		self.terrain.setBlockSize(32)
		#self.terrain.setFactor(256)
		#self.terrain.setFocalPoint(base.camera.getPos())
		self.terrain.getRoot().reparentTo(render)
		
		taskMgr.add(self.updateTask, "update")
		
		self.mTerrainHeight = MAPSIZE/20#(TEXSIZE/50)
		self.mHorizontalScale = MAPSIZE/TEXSIZE
		
		self.mHeightFieldNode = self.terrain.getRoot()
		self.mHeightFieldNode.setPos( -MAPSIZE/2, -MAPSIZE/2, - self.mTerrainHeight/2)
		self.mHeightFieldNode.setSx(self.mHorizontalScale)
		self.mHeightFieldNode.setSy(self.mHorizontalScale)
		self.mHeightFieldNode.setSz(self.mTerrainHeight)
		
		self.terrain.generate()
		
		self.ts0 = TextureStage( 'dirtL0' )
		self.ts1 = TextureStage( 'dirtL1' )
		self.ts2 = TextureStage( 'dirtL3' )
		
		self.tex0 = loader.loadTexture( 'mud-tile.png' )
		
		self.tex0
		scale = 1.0
		self.mHeightFieldNode.setTexScale( self.ts0, scale, scale )
		self.mHeightFieldNode.setTexture( self.ts0, self.tex0, 1 )
		
		scale = 32.0
		self.mHeightFieldNode.setTexScale( self.ts1, scale, scale )
		self.mHeightFieldNode.setTexture( self.ts1, self.tex0, 1 )
		
		scale = 128.0
		self.mHeightFieldNode.setTexScale( self.ts2, scale, scale )
		self.mHeightFieldNode.setTexture( self.ts2, self.tex0, 1 )
		
		self.accept( "g", self.flattenArea)
		self.accept( "u", self.updateWithNewImage)
		
	
	def flattenArea( self ):
		tilePos = (500,500)
		tileSize = (4000,4000)
		
		imgTilePos = self.world2MapPos(tilePos)
		imgTileSize = self.world2MapPos( (tilePos[0] + tileSize[0], tilePos[1] + tileSize[1]) )
		imgTileSize = (imgTileSize[0] - imgTilePos[0], imgTileSize[1] - imgTilePos[1])
		
		tileSquare = PNMImage(Filename("tile.png"))
		
		tileStamp = PNMImage(int(imgTileSize[0] * (5/3)),int(imgTileSize[1] * (5/3)))
		tileStamp.makeGrayscale()
		tileStamp.addAlpha()
		
		tileStamp.gaussianFilterFrom(1, tileSquare)
		
		count = 4
		total = 0.0
		
		selectXLow = int(imgTilePos[0] + imgTileSize[0] * 0.25)
		selectXHigh = int(imgTilePos[0] + imgTileSize[0] * 0.75)
		selectYLow = int(imgTilePos[1] + imgTileSize[1] * 0.25)
		selectYHigh = int(imgTilePos[1] + imgTileSize[1] * 0.75)
		
		total += self.myImage.getGray(selectXLow,selectYLow)
		total += self.myImage.getGray(selectXLow,selectYLow)
		total += self.myImage.getGray(selectXHigh,selectYHigh)
		total += self.myImage.getGray(selectXHigh,selectYHigh)
		average = total/count
		
		tileStamp.fill(average)
		
		edgeWidth = imgTilePos[0]*(1/3)
		
		self.myImage.blendSubImage(tileStamp, int( imgTilePos[0]-edgeWidth), 
											  int( imgTilePos[1]-edgeWidth), 
										0, 0, int(imgTileSize[0]*( 5/3 )  ), 
											  int(imgTileSize[1]*( 5/3 )  ), 1)
		
	
	def makePath( self , startPos, endPos, modificationCost, colapseAngle):
		tilePos = (500,500)
		tileSize = (4000,4000)
		
		imgTilePos = self.world2MapPos(tilePos)
		imgTileSize = self.world2MapPos( (tilePos[0] + tileSize[0], tilePos[1] + tileSize[1]) )
		imgTileSize = (imgTileSize[0] - imgTilePos[0], imgTileSize[1] - imgTilePos[1])
		
		tileSquare = PNMImage(Filename("tile.png"))
		
		tileStamp = PNMImage(int(imgTileSize[0] * (5/3)),int(imgTileSize[1] * (5/3)))
		tileStamp.makeGrayscale()
		tileStamp.addAlpha()
		
		tileStamp.gaussianFilterFrom(1, tileSquare)
		
		count = 4
		total = 0.0
		
		selectXLow = int(imgTilePos[0] + imgTileSize[0] * 0.25)
		selectXHigh = int(imgTilePos[0] + imgTileSize[0] * 0.75)
		selectYLow = int(imgTilePos[1] + imgTileSize[1] * 0.25)
		selectYHigh = int(imgTilePos[1] + imgTileSize[1] * 0.75)
		
		total += self.myImage.getGray(selectXLow,selectYLow)
		total += self.myImage.getGray(selectXLow,selectYLow)
		total += self.myImage.getGray(selectXHigh,selectYHigh)
		total += self.myImage.getGray(selectXHigh,selectYHigh)
		average = total/count
		
		tileStamp.fill(average)
		
		edgeWidth = imgTilePos[0]*(1/3)
		
		self.myImage.blendSubImage(tileStamp, int( imgTilePos[0]-edgeWidth), 
											  int( imgTilePos[1]-edgeWidth), 0, 0, 
											  int(imgTileSize[0]*( 5/3 )  ), 
											  int(imgTileSize[1]*( 5/3 )  ), 1)
		
	
	def updateWithNewImage(self):
		self.terrain.setHeightfield(self.myImage)
	
	def updateTask(self,task):
		posX = base.camera.getX()  + MAPSIZE/2
		posY = base.camera.getY()  + MAPSIZE/2
		self.terrain.setFocalPoint(posX, posY)
		self.terrain.update()
		return task.cont
	
	def world2MapPos( self, in_pos ):
		result = (0,0)
		if abs(in_pos[0]) <= MAPSIZE/2.0 and abs(in_pos[1]) <= MAPSIZE/2.0:
			posX = (in_pos[0] + MAPSIZE/2.0) / self.mHorizontalScale
			posY = (in_pos[1] + MAPSIZE/2.0) / self.mHorizontalScale
			result = (posX,posY)
		return result
	
	def get_elevation( self, in_pos ):
		result = 0
		if abs(in_pos[0]) <= MAPSIZE/2.0 and abs(in_pos[1]) <= MAPSIZE/2.0:
			posX = (in_pos[0] + MAPSIZE/2.0) / self.mHorizontalScale
			posY = (in_pos[1] + MAPSIZE/2.0) / self.mHorizontalScale
			result = (self.terrain.getElevation(posX ,posY ) * self.mTerrainHeight) - self.mTerrainHeight/2
		
		return result
		
